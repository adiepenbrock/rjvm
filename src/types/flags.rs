use bitflags::bitflags;

bitflags! {
    /// Access flags are used to denote access permissions to and properties of
    /// classes and interfaces.
    /// For more information see: <https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.1>
    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct ClassAccessFlags: u16 {
        /// The `ACC_PUBLIC` flag is used to indicate that a class is public and
        /// can be accessed from outside its package.
        const ACC_PUBLIC = 0x0001;
        /// The `ACC_FINAL` flag is used to indicate that a class is final and
        /// cannot be subclassed.
        const ACC_FINAL = 0x0010;
        /// The `ACC_SUPER` flag is used to indicate which of two alternative
        /// semantics is to be expressed by the `invokespecial` instruction if
        /// it appears for a particular class or interface.
        ///
        /// This flag exists for backward compatibility with code compiled by older
        /// compilers. In JDK 1.0.2, the `ACC_SUPER` flag had no assigned meaning
        /// and Oracle's Java Virtual Machine implementation ignored the flag
        const ACC_SUPER = 0x0020;
        /// The `ACC_INTERFACE` flag is used to indicate that a particular class
        /// file defines an interface rather than a class. If the `ACC_INTERFACE`
        /// flag is set, the `ACC_ABSTRACT` flag must also be set. Furthermore, the
        /// flags `ACC_FINAL`, `ACC_SUPER`, `ACC_ENUM`, and `ACC_MODULE` must not be
        /// set.
        const ACC_INTERFACE = 0x0200;
        /// The `ACC_ABSTRACT` flag is used to indicate that a particular class
        /// or interface is abstract, and cannot be instantiated directly.
        const ACC_ABSTRACT = 0x0400;
        /// The `ACC_SYNTHETIC` flag is used to indicate that a particular class
        /// or interface was generated by a compiler and does not appear in the
        /// source code.
        const ACC_SYNTHETIC = 0x1000;
        /// the `ACC_ANNOTATION` flag is used to indicate that a particular class
        /// file defines an annotation type. If the `ACC_ANNOTATION` flag is set,
        /// the `ACC_INTERFACE` flag must also be set.
        const ACC_ANNOTATION = 0x2000;
        /// The `ACC_ENUM` flag is used to indicate that a particular class or
        /// its superclass is declared as an enum class.
        const ACC_ENUM = 0x4000;
        /// The `ACC_MODULE` is used to indicate that a particular class file
        /// defines a module, not a class or interface.
        const ACC_MODULE = 0x8000;
    }
}

impl Default for ClassAccessFlags {
    fn default() -> Self {
        Self::empty()
    }
}

bitflags! {
    /// Field access flags are used to denote access permissions to and properties
    /// of a partiuclar field.
    /// For more information see: <https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-4.html#jvms-4.5>
    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct FieldAccessFlags: u16 {
        /// The `ACC_PUBLIC` flag is used to indicate that a field is public and
        /// can be accessed from outside its package.
        const ACC_PUBLIC = 0x0001;
        /// The `ACC_PRIVATE` flag is used to indicate that a field is private and
        /// only accessible within the defining class and others classes belonging
        /// to the same nest.
        const ACC_PRIVATE = 0x0002;
        /// The `ACC_PROTECTED` flag is used to indicate that a field is protected
        /// and can be accessed from within its package and by subclasses.
        const ACC_PROTECTED = 0x0004;
        /// The `ACC_STATIC` flag is used to indicate that a field is static.
        const ACC_STATIC = 0x0008;
        /// The `ACC_FINAL` flag is used to indicate that a field is final and may
        /// not be modified after object construction.
        const ACC_FINAL = 0x0010;
        /// The `ACC_VOLATILE` flag is used to indicate that a field is volatile and
        /// cannot be cached by threads.
        const ACC_VOLATILE = 0x0040;
        /// The `ACC_TRANSIENT` flag is used to indicate that a field is transient and
        /// may not be written or read by a persistent object manager.
        const ACC_TRANSIENT = 0x0080;
        /// The `ACC_SYNTHETIC` flag is used to indicate that a field is synthetic, i.e.,
        /// not present in the source code, and was generated by a compiler.
        const ACC_SYNTHETIC = 0x1000;
        /// The `ACC_ENUM` flag is used to indicate that a field is an element of an
        /// enum class.
        const ACC_ENUM = 0x4000;
    }
}

impl Default for FieldAccessFlags {
    fn default() -> Self {
        Self::empty()
    }
}

bitflags! {
    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct MethodAccessFlags: u16 {
        /// The `ACC_PUBLIC` flag is used to indicate that a method is public and
        /// can be accessed from outside its package.
        const ACC_PUBLIC = 0x0001;
        /// The `ACC_PRIVATE` flag is used to indicate that a method is private and
        /// only accessible within the defining class and others classes belonging
        /// to the same nest.
        const ACC_PRIVATE = 0x0002;
        /// The `ACC_PROTECTED` flag is used to indicate that a method is protected
        /// and can be accessed from within its package and by subclasses.
        const ACC_PROTECTED = 0x0004;
        /// The `ACC_STATIC` flag is used to indicate that a method is static.
        const ACC_STATIC = 0x0008;
        /// The `ACC_FINAL` flag is used to indicate that a method is final and may
        /// not be overridden.
        const ACC_FINAL = 0x0010;
        /// The `ACC_SYNCHRONIZED` flag is used to indicate that a method is synchronized
        /// and can only be accessed by one thread at a time.
        const ACC_SYNCHRONIZED = 0x0020;
        /// The `ACC_BRIDGE` flag is used to indicate that a method is a bridge method
        /// generated by the compiler.
        const ACC_BRIDGE = 0x0040;
        /// The `ACC_VARARGS` flag is used to indicate that a method has a variable number
        /// of arguments.
        const ACC_VARARGS = 0x0080;
        /// The `ACC_NATIVE` flag is used to indicate that a method is native and
        /// implemented in a language other than Java.
        const ACC_NATIVE = 0x0100;
        /// The `ACC_ABSTRACT` flag is used to indicate that a method is abstract and
        /// no implementation is provided.
        const ACC_ABSTRACT = 0x0400;
        /// The `ACC_STRICT` flag is used to indicate that a method is strictfp and
        /// uses the strict floating-point mode.
        const ACC_STRICT = 0x0800;
        /// The `ACC_SYNTHETIC` flag is used to indicate that a method is synthetic, i.e.,
        /// not present in the source code, and was generated by a compiler.
        const ACC_SYNTHETIC = 0x1000;
    }
}

impl Default for MethodAccessFlags {
    fn default() -> Self {
        Self::empty()
    }
}

bitflags! {
    #[derive(Debug, Clone, PartialEq, Eq)]
    pub struct InnerClassAccessFlags: u16 {
        const ACC_PUBLIC = 0x0001;
        const ACC_PRIVATE = 0x0002;
        const ACC_PROTECTED = 0x0004;
        const ACC_STATIC = 0x0008;
        const ACC_FINAL = 0x0010;
        const ACC_INTERFACE = 0x0200;
        const ACC_ABSTRACT = 0x0400;
        const ACC_SYNTHETIC = 0x1000;
        const ACC_ANNOTATION = 0x2000;
        const ACC_ENUM = 0x4000;
    }
}

impl Default for InnerClassAccessFlags {
    fn default() -> Self {
        Self::empty()
    }
}
